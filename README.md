## Coding Practice


# Code-DSA

Welcome to the Code-DSA repository! This repository contains my implementations of various data structures and algorithms in Java. It serves as a learning resource for data structures and algorithms.

## Contents

The repository is organized into different directories, each focusing on a specific topic. Here's an overview of the contents:

- `Arrays`: Implementations and examples related to array manipulation, searching, and sorting algorithms.
- `LinkedLists`: Implementations of singly linked lists, doubly linked lists, and related operations.
- `Stacks`: Implementation of the stack data structure and related algorithms.
- `Queues`: Implementation of the queue data structure and related algorithms.
- `Trees`: Implementations of various tree data structures such as binary trees, binary search trees, and balanced trees, along with traversal algorithms.
- `Graphs`: Implementations of graph data structures and common algorithms like breadth-first search and depth-first search.
- `Sorting`: Implementations of various sorting algorithms like bubble sort, selection sort, merge sort, and quicksort.
- `Searching`: Implementations of searching algorithms like linear search, binary search, and interpolation search.
- `DynamicProgramming`: Implementations of dynamic programming algorithms for solving optimization problems.


Feel free to explore the directories and browse the code. Each directory contains detailed explanations, code examples, and notes to help you understand the concepts and algorithms better.

---
## List of common time complexity terms used in Big O notation:

1. **O(1)**: Constant time complexity. The algorithm takes a constant amount of time to complete, regardless of the input size.
2. **O(log n)**: Logarithmic time complexity. The algorithm's running time increases logarithmically with the input size.
3. **O(n)**: Linear time complexity. The algorithm's running time increases linearly with the input size.
4. **O(n log n)**: Linearithmic time complexity. The algorithm's running time increases in proportion to the input size multiplied by the logarithm of the input size.
5. **O(n^2)**: Quadratic time complexity. The algorithm's running time increases quadratically with the input size.
6. **O(2^n)**: Exponential time complexity. The algorithm's running time grows exponentially with the input size.
7. **O(n!)**: Factorial time complexity. The algorithm's running time grows factorially with the input size.

These terms represent the rate at which the running time of an algorithm increases as the input size grows. It helps in analyzing and comparing the efficiency of algorithms.

---
## Arrays

This directory contains my solutions to various array-related problems. Each problem is implemented in Java and includes detailed explanations, code examples. The goal is to provide a comprehensive collection of array exercises to help you strengthen your understanding of array manipulation, searching, and sorting algorithms.

You can find the solutions to the array problems in the [Arrays](https://github.com/hassanshahzadaheer/Code-DSA/tree/main/Arrays) directory.


## Usage

You can clone this repository to your local machine using the following command:

git clone [https://github.com/hassanshahzadaheer/Code-DSA/](https://github.com/hassanshahzadaheer/Code-DSA/)


Once cloned, you can navigate to the respective directories to view the code files and accompanying explanations.

## Contributions

Contributions to this repository are welcome! If you have any improvements, bug fixes, or additional algorithms that you would like to share, feel free to open a pull request. Please make sure to follow the existing code style and provide clear explanations.

## License

This repository is licensed under the [MIT License](LICENSE). You are free to use the code for educational purposes and modify it according to your needs.

Happy coding and learning!

